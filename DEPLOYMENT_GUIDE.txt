================================================================================
                    TÀI LIỆU TRIỂN KHAI HỆ THỐNG
           AutoParts Portal - Hệ thống quản lý phụ tùng ô tô
================================================================================

I. TỔNG QUAN VỀ TRIỂN KHAI

1.1. Mục tiêu triển khai
   - Đưa ứng dụng fullstack lên môi trường production
   - Đảm bảo tính sẵn sàng 24/7 cho người dùng cuối
   - Tích hợp AI/ML model (YOLOv8 + Gemini API) trong môi trường cloud
   - Tối ưu hiệu năng và chi phí vận hành

1.2. Nền tảng triển khai được chọn: Render.com
   
   Lý do lựa chọn Render:
   - Free tier hỗ trợ PostgreSQL database (256MB RAM)
   - Hỗ trợ Docker runtime cho Python dependencies
   - Auto-deploy từ GitHub repository
   - SSL/HTTPS miễn phí
   - CDN tích hợp sẵn
   - Phù hợp cho dự án học tập và demo

   Hạn chế cần lưu ý:
   - RAM giới hạn (512MB cho web service, 256MB cho database)
   - Cold start sau 15 phút không hoạt động (free tier)
   - Băng thông giới hạn 100GB/tháng

================================================================================

II. KIẾN TRÚC TRIỂN KHAI

2.1. Cấu trúc tổng quan

   ┌─────────────────────────────────────────────────────────────┐
   │                    RENDER PLATFORM                          │
   │                                                             │
   │  ┌──────────────────────────────────────────────────────┐  │
   │  │  Web Service (Docker Container)                      │  │
   │  │  - Node.js 20 (Backend API)                          │  │
   │  │  - Python 3.11 (AI/ML Models)                        │  │
   │  │  - React (Frontend - Static Build)                   │  │
   │  │  - RAM: 512MB                                        │  │
   │  └──────────────────────────────────────────────────────┘  │
   │                          ↕                                  │
   │  ┌──────────────────────────────────────────────────────┐  │
   │  │  PostgreSQL Database                                 │  │
   │  │  - Version: 16                                       │  │
   │  │  - RAM: 256MB                                        │  │
   │  │  - Storage: 1GB                                      │  │
   │  └──────────────────────────────────────────────────────┘  │
   │                                                             │
   │  External Services:                                         │
   │  - Gemini API (Google AI)                                   │
   │  - GitHub (Source Control & Auto-deploy)                    │
   └─────────────────────────────────────────────────────────────┘

2.2. Luồng triển khai tự động (CI/CD)

   Developer → Git Push → GitHub Repository → Render Webhook → 
   Build Docker Image → Deploy Container → Health Check → Live

================================================================================

III. QUÁ TRÌNH TRIỂN KHAI CHI TIẾT

3.1. Chuẩn bị môi trường

   A. Cấu trúc dự án:
      autoparts_full/
      ├── autoparts-backend/          # Node.js + Express API
      │   ├── server.js               # Entry point
      │   ├── detector.py             # Python AI model
      │   ├── requirements.txt        # Python dependencies
      │   ├── package.json            # Node.js dependencies
      │   └── uploads/                # User uploaded images
      │
      ├── autoparts-frontend/         # React SPA
      │   ├── src/                    # Source code
      │   ├── dist/                   # Production build
      │   └── package.json
      │
      ├── Dockerfile                  # Multi-stage build config
      ├── .gitignore                  # Git ignore rules
      └── README.md                   # Documentation

   B. Biến môi trường (Environment Variables):
      - DATABASE_URL: PostgreSQL connection string
      - JWT_SECRET: Secret key cho JSON Web Token
      - GEMINI_API_KEY: API key cho Google Gemini AI
      - PORT: Cổng server (mặc định: 4000)
      - NODE_ENV: production

3.2. Dockerfile - Cấu hình Container

   Chiến lược: Multi-language container (Node.js + Python)
   
   A. Base Image Selection:
      - Chọn: node:20-bookworm
      - Lý do: 
        + Debian Bookworm có Python 3.11 built-in
        + Tương thích tốt với các thư viện AI/ML
        + Kích thước image hợp lý (~900MB)

   B. Cài đặt Python Environment:
      
      # Cài đặt Python và dependencies hệ thống
      RUN apt-get update && apt-get install -y \
          python3 \
          python3-venv \
          python3-pip \
          libgl1-mesa-glx \      # OpenCV dependency
          libglib2.0-0           # OpenCV dependency

      # Tạo virtual environment (tuân thủ PEP 668)
      RUN python3 -m venv /opt/venv
      ENV PATH="/opt/venv/bin:$PATH"

   C. Cài đặt PyTorch (CPU-only):
      
      Vấn đề gặp phải:
      - PyTorch 2.6+ có lỗi "weights_only safe globals" với YOLOv8
      - GPU version quá nặng cho free tier
      
      Giải pháp:
      - Downgrade xuống PyTorch 2.4.0 (CPU-only)
      - Cài đặt torchvision 0.19.0 tương thích
      
      RUN pip install numpy
      RUN pip install torch==2.4.0 torchvision==0.19.0 \
          --index-url https://download.pytorch.org/whl/cpu

   D. Cài đặt Ultralytics (YOLOv8):
      
      Vấn đề: Model weights có cấu trúc C3k2 không tương thích với version cũ
      
      Giải pháp: Unpin version để lấy latest
      
      requirements.txt:
      ultralytics          # Không pin version
      google-generativeai
      opencv-python-headless
      python-dotenv
      numpy
      Pillow

   E. Build Process:
      
      1. Copy toàn bộ source code
      2. Install frontend dependencies
      3. Build frontend (npm run build)
      4. Install backend dependencies
      5. Install Python dependencies
      6. Expose port 4000
      7. Start command: node server.js

3.3. Database Setup

   A. Tạo PostgreSQL Database trên Render:
      - Service type: PostgreSQL
      - Version: 16
      - Region: Singapore (gần Việt Nam nhất)
      - Plan: Free tier (256MB RAM, 1GB storage)

   B. Migration Scripts:
      
      Đã tạo các script migration:
      - migrate_prod_db.js: Tạo toàn bộ schema ban đầu
      - create_cart_table.js: Thêm bảng giỏ hàng
      - optimize_db.js: Thêm indexes để tối ưu query
      - fix_orders_overflow.js: Fix lỗi numeric overflow

      Cách chạy migration:
      1. Set DATABASE_URL trong .env
      2. node migrate_prod_db.js
      3. Kiểm tra logs để đảm bảo thành công

   C. Schema chính:
      - users: Quản lý tài khoản (admin, user)
      - products: Danh mục sản phẩm
      - orders: Đơn hàng
      - cart: Giỏ hàng lưu theo user
      - reviews: Đánh giá sản phẩm
      - consultations: Tư vấn khách hàng
      - import_logs: Lịch sử nhập kho
      - user_addresses: Địa chỉ giao hàng

   D. Indexes để tối ưu:
      - GIN trigram index trên products.name (full-text search)
      - B-tree index trên products.part (filter theo loại)
      - B-tree index trên orders.user_email (query đơn hàng)
      - B-tree index trên cart.user_email (load giỏ hàng)

3.4. Backend Configuration

   A. Server.js - Entry Point:
      
      Cấu hình CORS:
      app.use(cors({
        origin: (origin, callback) => {
          if (!origin || 
              origin.includes('localhost') ||
              origin.includes('onrender.com')) {
            return callback(null, true);
          }
          callback(new Error('Not allowed by CORS'));
        },
        credentials: true
      }));

   B. Static File Serving:
      
      1. Uploads folder (user images):
         app.use('/uploads', express.static('uploads'));

      2. Pre-existing image folders:
         app.use('/uploads/NgoaiThat4Web', 
                 express.static('../NgoaiThat4Web/images'));
         app.use('/uploads/NoiThat4Web', 
                 express.static('../NoiThat4Web/images'));
         app.use('/uploads/ThietBi4Web', 
                 express.static('../ThietBi4Web/images'));

      3. Frontend build:
         app.use(express.static('../autoparts-frontend/dist'));
         
         // SPA fallback
         app.get('*', (req, res) => {
           if (!req.path.startsWith('/api/')) {
             res.sendFile('dist/index.html');
           }
         });

   C. AI Model Integration:
      
      Lazy Loading Strategy (tiết kiệm RAM):
      
      # detector.py
      damage_model = None
      part_model = None

      def load_models():
          global damage_model, part_model
          if damage_model is None:
              damage_model = YOLO('damage_model.pt')
          if part_model is None:
              part_model = YOLO('part_model.pt')

      Spawn Python Process từ Node.js:
      
      const pythonProcess = spawn('python3', ['detector.py', imagePath], {
        env: {
          ...process.env,
          GEMINI_API_KEY: process.env.GEMINI_API_KEY,
          GOOGLE_API_KEY: process.env.GOOGLE_API_KEY
        }
      });

   D. Security Enhancements:
      - helmet.js: Security headers
      - bcrypt: Password hashing (10 rounds)
      - JWT: Stateless authentication
      - Input validation: Email format, password strength
      - SQL injection prevention: Parameterized queries

3.5. Frontend Build & Optimization

   A. Build Configuration (Vite):
      
      vite.config.js:
      export default defineConfig({
        plugins: [react()],
        build: {
          outDir: 'dist',
          rollupOptions: {
            output: {
              manualChunks: {
                vendor: ['react', 'react-dom'],
                charts: ['recharts']
              }
            }
          }
        }
      });

   B. Code Splitting:
      - Lazy loading cho các route lớn
      - Dynamic imports cho components nặng
      
      const DashBoard = lazy(() => import('./components/DashBoard.jsx'));
      const ManageProducts = lazy(() => import('./components/ManageProducts.jsx'));

   C. Asset Optimization:
      - Images: WebP format (giảm 30-50% kích thước)
      - CSS: Minified và tree-shaken
      - JS: Code splitting theo route

   D. Performance Metrics:
      - Initial bundle: ~175KB (gzipped: ~55KB)
      - Largest chunk (DashBoard): ~195KB (gzipped: ~66KB)
      - Total build size: ~500KB

================================================================================

IV. QUY TRÌNH DEPLOY

4.1. Deployment Workflow

   Step 1: Chuẩn bị code
      git add -A
      git commit -m "Deploy: [description]"
      git push origin main

   Step 2: Render Auto-deploy
      - Webhook trigger từ GitHub
      - Pull latest code
      - Build Docker image (5-10 phút)
      - Run health checks
      - Deploy container mới
      - Terminate container cũ

   Step 3: Verification
      - Check deployment logs
      - Test API endpoints
      - Test frontend routes
      - Verify database connection
      - Test AI model inference

4.2. Environment Variables Setup trên Render

   Web Service Environment:
   ┌─────────────────────┬──────────────────────────────────────┐
   │ Variable            │ Value                                │
   ├─────────────────────┼──────────────────────────────────────┤
   │ DATABASE_URL        │ postgres://user:pass@host:5432/db    │
   │ JWT_SECRET          │ [random 64-char string]              │
   │ GEMINI_API_KEY      │ [Google AI API key]                  │
   │ PORT                │ 4000                                 │
   │ NODE_ENV            │ production                           │
   └─────────────────────┴──────────────────────────────────────┘

4.3. Build Settings

   Build Command: (Render tự động detect từ Dockerfile)
   Start Command: node server.js
   
   Docker Build:
   - Context: Root directory
   - Dockerfile: ./Dockerfile
   - Build arguments: None
   - Auto-deploy: Yes (on git push)

4.4. Health Checks

   Render tự động ping endpoint:
   - URL: https://[app-name].onrender.com/
   - Interval: 30 seconds
   - Timeout: 30 seconds
   - Unhealthy threshold: 3 failures

   Custom health endpoint (optional):
   app.get('/health', (req, res) => {
     res.json({ 
       status: 'ok', 
       timestamp: new Date().toISOString(),
       uptime: process.uptime()
     });
   });

================================================================================

V. VẤN ĐỀ ĐÃ GIẢI QUYẾT TRONG QUÁ TRÌNH DEPLOY

5.1. PyTorch Compatibility Issues

   Vấn đề:
   - PyTorch 2.6+ không load được YOLO weights
   - Error: "weights_only safe globals"
   
   Nguyên nhân:
   - PyTorch 2.6 tăng cường bảo mật, chặn load pickle unsafe
   - YOLO model sử dụng custom classes không được whitelist
   
   Giải pháp:
   - Downgrade PyTorch xuống 2.4.0
   - Sử dụng CPU-only build để giảm kích thước
   - Install torchvision 0.19.0 tương thích

5.2. Ultralytics Version Mismatch

   Vấn đề:
   - Model có module C3k2 không tồn tại trong ultralytics cũ
   - Error: "AttributeError: module 'ultralytics' has no attribute 'C3k2'"
   
   Giải pháp:
   - Unpin ultralytics version trong requirements.txt
   - Để Render tự động cài latest version
   - Latest version có đầy đủ modules mới

5.3. Python Environment (PEP 668)

   Vấn đề:
   - Debian Bookworm chặn pip install global
   - Error: "externally-managed-environment"
   
   Giải pháp:
   - Tạo Python virtual environment: /opt/venv
   - Set PATH để ưu tiên venv
   - Install tất cả packages trong venv

5.4. Gemini API Key Not Found

   Vấn đề:
   - Python subprocess không nhận được GEMINI_API_KEY
   - Error: "No API_KEY"
   
   Nguyên nhân:
   - spawn() không tự động pass environment variables
   
   Giải pháp:
   - Explicitly pass env trong spawn options:
     spawn('python3', ['detector.py'], {
       env: {
         ...process.env,
         GEMINI_API_KEY: process.env.GEMINI_API_KEY
       }
     });

5.5. Memory Constraints (512MB RAM)

   Vấn đề:
   - PyTorch + Ultralytics + 2 YOLO models = ~800MB RAM
   - Container bị kill do OOM (Out of Memory)
   
   Giải pháp:
   - Lazy loading: Chỉ load model khi cần
   - CPU-only PyTorch (nhẹ hơn GPU version)
   - Unload model sau khi inference xong (nếu cần)

5.6. Static File Serving

   Vấn đề:
   - Frontend assets (JS, CSS) trả về 404
   - MIME type mismatch errors
   
   Giải pháp:
   - Serve frontend dist folder với express.static
   - SPA fallback routing cho React Router
   - Cache control headers để tránh stale cache

5.7. Database Schema Migration

   Vấn đề:
   - Thiếu columns mới (brand, description, specifications)
   - Numeric overflow với orders.total
   
   Giải pháp:
   - Tạo migration scripts kiểm tra và thêm columns
   - ALTER TABLE để đổi data types
   - Chạy migrations trước khi deploy code mới

5.8. Cart Persistence

   Vấn đề:
   - Giỏ hàng mất khi F5 hoặc đăng xuất/đăng nhập lại
   
   Giải pháp:
   - Tạo bảng cart trong database
   - API endpoints: GET, POST, PUT, DELETE cart
   - Auto-sync cart khi đăng nhập
   - Clear cart khi đăng xuất

5.9. Image Display in Cart

   Vấn đề:
   - Ảnh trong giỏ hàng hiển thị broken image
   - Column name mismatch: image vs image_path
   
   Giải pháp:
   - Backend query: SELECT p.image_path
   - Frontend mapping: image_path → image
   - Component render: src={i.image}

================================================================================

VI. MONITORING & MAINTENANCE

6.1. Logging Strategy

   A. Application Logs:
      - console.log() cho info messages
      - console.error() cho errors
      - Render tự động capture và hiển thị logs

   B. Database Logs:
      - Query errors được log với full stack trace
      - Slow queries (>1s) được highlight

   C. AI Model Logs:
      - Python print() output được capture
      - Inference time tracking
      - Error handling cho failed predictions

6.2. Performance Monitoring

   Metrics được theo dõi:
   - Response time: Trung bình <200ms
   - Database query time: <50ms
   - AI inference time: 2-5 giây
   - Memory usage: <400MB steady state
   - CPU usage: <50% average

6.3. Error Handling

   A. Frontend:
      - Try-catch cho API calls
      - Toast notifications cho user-friendly errors
      - Fallback UI cho lazy-loaded components

   B. Backend:
      - Global error handler middleware
      - Specific error messages (401, 404, 500)
      - Database transaction rollback

   C. AI Model:
      - Graceful degradation nếu model fail
      - Fallback message cho user
      - Retry logic cho transient errors

6.4. Backup Strategy

   A. Database:
      - Render tự động backup daily (free tier: 7 days retention)
      - Manual backup: pg_dump qua psql connection
      - Export critical data định kỳ

   B. Uploaded Images:
      - Lưu trên container filesystem (ephemeral)
      - Khuyến nghị: Migrate sang S3/Cloudinary cho production

   C. Source Code:
      - Git repository trên GitHub
      - Multiple branches: main, develop, feature/*
      - Tagged releases cho mỗi deployment

================================================================================

VII. SCALING & OPTIMIZATION

7.1. Hiện tại (Free Tier)

   Limitations:
   - 512MB RAM (web service)
   - 256MB RAM (database)
   - Cold start sau 15 phút idle
   - 100GB bandwidth/tháng
   - Shared CPU

   Phù hợp cho:
   - Demo projects
   - Development/testing
   - Low traffic applications (<1000 users/tháng)

7.2. Khuyến nghị nâng cấp (Production)

   A. Web Service:
      - Plan: Starter ($7/tháng)
      - RAM: 2GB
      - CPU: Dedicated
      - No cold starts
      - 100GB bandwidth included

   B. Database:
      - Plan: Starter ($7/tháng)
      - RAM: 1GB
      - Storage: 10GB
      - Backup retention: 30 days
      - Connection pooling

   C. CDN & Caching:
      - Cloudflare (free tier)
      - Cache static assets
      - DDoS protection
      - Global CDN

7.3. Horizontal Scaling

   Khi traffic tăng:
   - Multiple web service instances (load balancer)
   - Redis cho session storage
   - Separate AI service (microservices)
   - Database read replicas

7.4. Code Optimization

   Đã thực hiện:
   - Lazy loading components
   - Database indexes
   - Query optimization (JOIN thay vì N+1)
   - Compression middleware (gzip)
   - Cache control headers

   Có thể cải thiện:
   - Server-side caching (Redis)
   - Image CDN (Cloudinary)
   - API rate limiting
   - GraphQL thay vì REST (giảm over-fetching)

================================================================================

VIII. SECURITY CONSIDERATIONS

8.1. Authentication & Authorization

   - JWT tokens (expire sau 7 ngày)
   - Password hashing: bcrypt (10 rounds)
   - Role-based access control (admin, user)
   - Protected routes middleware

8.2. Input Validation

   - Email format validation (regex)
   - Password strength requirements
   - SQL injection prevention (parameterized queries)
   - XSS prevention (React auto-escaping)

8.3. Network Security

   - HTTPS only (Render provides free SSL)
   - CORS configuration (whitelist domains)
   - Helmet.js security headers
   - Rate limiting (planned)

8.4. Data Protection

   - Sensitive data in environment variables
   - .gitignore cho .env files
   - Database connection over SSL
   - No hardcoded credentials

================================================================================

IX. TESTING & QUALITY ASSURANCE

9.1. Testing Strategy

   A. Local Testing:
      - npm run dev (frontend)
      - node server.js (backend)
      - Test trên localhost:4000

   B. Staging Environment:
      - Render preview deployments
      - Test trên URL tạm thời
      - Verify trước khi merge vào main

   C. Production Testing:
      - Smoke tests sau mỗi deployment
      - User acceptance testing
      - Performance testing

9.2. Test Cases

   Critical Flows:
   ✓ User registration & login
   ✓ Product catalog browsing
   ✓ Add to cart & checkout
   ✓ AI damage detection
   ✓ Admin product management
   ✓ Order management
   ✓ Review & consultation submission

9.3. Known Issues & Workarounds

   Issue 1: Cold Start Latency
   - Symptom: First request sau 15 phút mất 10-30 giây
   - Workaround: Ping endpoint định kỳ (cron job)

   Issue 2: AI Model Loading Time
   - Symptom: First AI request mất 5-10 giây
   - Workaround: Lazy loading + loading indicator

   Issue 3: Limited Storage
   - Symptom: Uploaded images bị mất khi redeploy
   - Workaround: Sử dụng external storage (S3, Cloudinary)

================================================================================

X. KẾT LUẬN

10.1. Thành tựu đạt được

   ✓ Triển khai thành công fullstack application lên cloud
   ✓ Tích hợp AI/ML models (YOLOv8 + Gemini) trong production
   ✓ Database migration và optimization
   ✓ CI/CD pipeline tự động từ GitHub
   ✓ Security best practices
   ✓ Performance optimization
   ✓ Persistent shopping cart
   ✓ Professional error handling & UX

10.2. Bài học kinh nghiệm

   1. Dependency Management:
      - Pin critical versions (PyTorch)
      - Unpin flexible versions (Ultralytics)
      - Test compatibility trước khi deploy

   2. Resource Constraints:
      - Free tier có giới hạn nghiêm ngặt
      - Lazy loading và optimization là bắt buộc
      - Monitor memory usage liên tục

   3. Environment Parity:
      - Local development khác production
      - Test trên staging environment trước
      - Document tất cả environment variables

   4. Error Handling:
      - Graceful degradation quan trọng
      - User-friendly error messages
      - Comprehensive logging

10.3. Hướng phát triển tiếp theo

   Short-term (1-3 tháng):
   - Migrate images sang Cloudinary
   - Implement Redis caching
   - Add API rate limiting
   - Improve AI model accuracy

   Mid-term (3-6 tháng):
   - Microservices architecture
   - Separate AI service
   - Real-time notifications (WebSocket)
   - Mobile app (React Native)

   Long-term (6-12 tháng):
   - Multi-region deployment
   - Advanced analytics dashboard
   - Machine learning recommendations
   - Payment gateway integration

================================================================================

PHỤ LỤC A: DEPLOYMENT CHECKLIST

Pre-deployment:
□ Code review completed
□ All tests passing
□ Environment variables configured
□ Database migrations prepared
□ Frontend build successful
□ Docker image builds locally
□ .gitignore updated

Deployment:
□ Git push to main branch
□ Monitor Render build logs
□ Verify deployment success
□ Run smoke tests
□ Check application logs
□ Verify database connection
□ Test critical user flows

Post-deployment:
□ Monitor error rates
□ Check performance metrics
□ Verify AI model functionality
□ Test on multiple devices/browsers
□ Update documentation
□ Notify stakeholders

================================================================================

PHỤ LỤC B: USEFUL COMMANDS

Local Development:
  npm run dev                    # Start frontend dev server
  node server.js                 # Start backend server
  npm run build                  # Build frontend for production

Database:
  node migrate_prod_db.js        # Run migrations
  node create_cart_table.js      # Add cart table
  node optimize_db.js            # Add indexes

Git:
  git add -A                     # Stage all changes
  git commit -m "message"        # Commit changes
  git push origin main           # Deploy to production

Docker (local testing):
  docker build -t autoparts .    # Build image
  docker run -p 4000:4000 autoparts  # Run container

================================================================================

PHỤ LỤC C: CONTACT & SUPPORT

Project Repository: https://github.com/[username]/autoparts_full
Render Dashboard: https://dashboard.render.com
Documentation: README.md, POSTMAN_TESTING_GUIDE.md

Technical Support:
- GitHub Issues: For bug reports
- Email: [your-email]
- Documentation: In-code comments

================================================================================

Tài liệu này được tạo ngày: 07/12/2025
Phiên bản: 1.0
Tác giả: [Tên của bạn]
Dự án: AutoParts Portal - Hệ thống quản lý phụ tùng ô tô

================================================================================
